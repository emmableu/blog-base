---
title: Task 2 - CNN and RNN on Sentiment Analysis
date: 2022-04-10 14:05:49
permalink: /pages/c4a179/
categories:
  - 机器学习八股文
  - FudanNLP
tags:
  - 
---
### 任务二：基于深度学习的文本分类  
  
## Requirements
**实验目的**  
  
用Pytorch重写《任务一》，实现基于CNN、RNN的文本分类  
  
**实验内容**  
1）词嵌入初始化方式：随机embedding、加载glove  
2）CNN/RNN的特征抽取  
3）Dropout  

1.  参考
    
    1.  [https://pytorch.org/](https://pytorch.org/)
    2.  Convolutional Neural Networks for Sentence Classification [https://arxiv.org/abs/1408.5882](https://arxiv.org/abs/1408.5882)
    3.  [https://machinelearningmastery.com/sequence-classification-lstm-recurrent-neural-networks-python-keras/](https://machinelearningmastery.com/sequence-classification-lstm-recurrent-neural-networks-python-keras/)
2.  word embedding 的方式初始化
    
3.  随机embedding的初始化方式
    
4.  用glove 预训练的embedding进行初始化 [https://nlp.stanford.edu/projects/glove/](https://nlp.stanford.edu/projects/glove/)
  
**其它参考**  
- https://arxiv.org/abs/1408.5882  
- https://github.com/yokusama/CNN_Sentence_Classification  
- torchtext: https://torchtext.readthedocs.io/en/latest/  
- http://mlexplained.com/2018/02/08/a-comprehensive-tutorial-to-torchtext/  
- https://machinelearningmastery.com/sequence-classification-lstm-recurrent-neural-networks-python-keras/  
- https://github.com/yunjey/pytorch-tutorial/blob/master/tutorials/02-intermediate/bidirectional_recurrent_neural_network/main.py#L39-L58

## API Knowledge
### `np.random.seed()`
`np.random.seed(0)` makes the random numbers predictable

```python
>>> numpy.random.seed(0) ; numpy.random.rand(4)
array([ 0.55,  0.72,  0.6 ,  0.54])
>>> numpy.random.seed(0) ; numpy.random.rand(4)
array([ 0.55,  0.72,  0.6 ,  0.54])
```

With the seed reset (every time), the _same_ set of numbers will appear every time.

If the random seed is not reset, _different_ numbers appear with every invocation:

```python
>>> numpy.random.rand(4)
array([ 0.42,  0.65,  0.44,  0.89])
>>> numpy.random.rand(4)
array([ 0.96,  0.38,  0.79,  0.53])
```

`np.random.seed(0)` makes the random numbers predictable

```python
>>> numpy.random.seed(0) ; numpy.random.rand(4)
array([ 0.55,  0.72,  0.6 ,  0.54])
>>> numpy.random.seed(0) ; numpy.random.rand(4)
array([ 0.55,  0.72,  0.6 ,  0.54])
```

With the seed reset (every time), the _same_ set of numbers will appear every time.

If the random seed is not reset, _different_ numbers appear with every invocation:

```python
>>> numpy.random.rand(4)
array([ 0.42,  0.65,  0.44,  0.89])
>>> numpy.random.rand(4)
array([ 0.96,  0.38,  0.79,  0.53])
```

(pseudo-)random numbers work by starting with a number (the seed), multiplying it by a large number, adding an offset, then taking modulo of that sum. The resulting number is then used as the seed to generate the next "random" number. When you set the seed (every time), it does the same thing every time, giving you the same numbers.


