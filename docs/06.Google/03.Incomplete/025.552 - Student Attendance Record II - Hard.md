tags: [Dynamic Programming]

[LC Link](https://leetcode.cn/problems/student-attendance-record-ii/)

<img width="700" alt="image" src="https://user-images.githubusercontent.com/41789327/180881764-3d4af2a1-a8f1-42d5-aee6-90efc7e6db00.png">

## 1. 两个超时的DFS

```python
class Solution:
	def __init__(self):
		self.mod = 10 ** 9 + 7
		
	def checkRecord(self, n):
		return self.dfs(n, 0, 0, 'p', 'p')

	def dfs(self, n, cur_len, a_cnt, prev, prev2):
		if cur_len == n:
			return 1
		res = 0
		# 1. present 随便放
		res += self.dfs(n, cur_len + 1, a_cnt, 'p', prev) % self.mod
		# 2. Absent最多只能放一个
		if a_cnt == 0:
			res += self.dfs(n, cur_len + 1, a_cnt + 1, 'a', prev) % self.mod
		# 3. Late最多连续放2个
		if prev + prev2 != 'll':
			res += self.dfs(n, cur_len + 1, a_cnt, 'l', prev) % self.mod
		res = res % self.mod
		return res
```

优化上面的写法： 
1. 我们其实不需要记录上两个是什么，只要记录连续的 l 有几个 (`l_cnt`)
	只要是 present 和 absent 的情况，就把`l_cnt` 清空为0， 
	只要是 late 的情况 `l_cnt` 就 + 1

2. 用 space_left 代替 n 和 cur_len, `space_left = n - cur_len` 方便后面做memoization优化
```python
class Solution:
	def __init__(self):
		self.mod = 10 ** 9 + 7
		
	def checkRecord(self, n):
		return self.dfs(n, 0, 0)

	def dfs(self, space_left, a_cnt, l_cnt):
		if space_left == 0:
			return 1
		res = 0
		res += self.dfs(space_left - 1, a_cnt, 0) % self.mod
		if a_cnt == 0:
			res += self.dfs(space_left - 1, a_cnt + 1, 0) % self.mod
		if l_cnt < 2:
			res += self.dfs(space_left - 1, a_cnt, l_cnt + 1) % self.mod
		res = res % self.mod
		return res
```



## 2.  (仍然不是最优解） - DFS with Memoization  (O(n) time complexity) 
以 n = 4 为例 用上面的第二个 DFS 画出递归树：
```
dfs(4, 0, 0)
	- dfs(3, 0, 0)
		- dfs(2, 0, 0)
		- dfs(2, 1, 0)
		- dfs(2, 0, 1)
	- dfs(3, 1, 0)
		- dfs(2, 1, 0)  # 和上面重复了！
		- dfs(2, 1, 1)
	- dfs(3, 0, 1)
		- dfs(2, 0, 1) # 和上面重复了！
		- dfs(2, 1, 1) # 和上面重复了！
		- dfs(2, 0, 2)
```

因为有多个重复点，所以可以用memoization优化

memo的维度：
```java
int[][][] memo = new int[n + 1][2][3];
```

```python
class Solution:
	def __init__(self):
		self.mod = 10 ** 9  + 7 
	def checkRecord(self, n):
		memo = [[[-999, -999, -999] for a_cnt in range(2)] for space_left in range(n + 1)]
		return self.dfs(n, 0, 0, memo)
	def dfs(self, space_left, a_cnt, l_cnt, memo):
		if space_left == 0:
			memo[0][a_cnt][l_cnt] = 1
			return 1
		if memo[space_left][a_cnt][l_cnt] != -999:
			return memo[space_left][a_cnt][l_cnt]
		res = 0
		res += self.dfs(space_left - 1, a_cnt, 0, memo) % self.mod
		if a_cnt == 0:
			res += self.dfs(space_left - 1, a_cnt + 1, 0, memo) % self.mod
		if l_cnt < 2:
			res += self.dfs(space_left - 1, a_cnt, l_cnt + 1, memo) % self.mod
		res %= self.mod
		memo[space_left][a_cnt][l_cnt] = res
		return res
```


## 3. 最优解： 矩阵快速幂 (O(log n) time complexity)
[source](https://leetcode.cn/problems/student-attendance-record-ii/solution/gong-shui-san-xie-yi-ti-san-jie-ji-yi-hu-fdfx/)

之所以在动态规划解法中强调更新状态的方式（方向）是「往回」还是「往前」，是因为对于存在线性关系（同时又具有结合律）的递推式，我们能够通过「矩阵快速幂」来进行加速.

由于 `a_cnt` 和 `l_cnt` 的取值范围都很小，其组合的状态只有 2 * 3 = 6 种，我们使用 `idx = a_cnt * 3 + l_cnt`来代指组合（通用的二维转一维方式）：

- idx = 0：`a_cnt = 0`, `lcnt = 0`
- idx = 1：`a_cnt = 0`, `lcnt = 1`
- idx = 2：`a_cnt = 0`, `lcnt = 2`
- idx = 3：`a_cnt = 1`, `lcnt = 0`
- idx = 4：`a_cnt = 1`, `lcnt = 1`
- idx = 5：`a_cnt = 1`, `lcnt = 2`

| idx, a_cnt, l_cnt | 0, 0, 0 | 1, 0, 1 | 2, 0, 2 | 3, 1, 0 | 4, 1, 1 | 5, 1, 2 |
| ----------------- | ------- | ------- | ------- | ------- | ------- | ------- |
| 0, 0, 0           |         |         |         |         |         |         |
| 1, 0, 1           |         |         |         |         |         |         |
| 2, 0, 2           |         |         |         |         |         |         |
| 3, 1, 0           |         |         |         |         |         |         |
| 4, 1, 1           |         |         |         |         |         |         |
| 5, 1, 2           |         |         |         |         |         |         |


作者：AC_OIer
链接：https://leetcode.cn/problems/student-attendance-record-ii/solution/gong-shui-san-xie-yi-ti-san-jie-ji-yi-hu-fdfx/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


作者：AC_OIer
链接：https://leetcode.cn/problems/student-attendance-record-ii/solution/gong-shui-san-xie-yi-ti-san-jie-ji-yi-hu-fdfx/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


