tags: [Dynamic Programming]

[LC Link](https://leetcode.cn/problems/student-attendance-record-ii/)

<img width="700" alt="image" src="https://user-images.githubusercontent.com/41789327/180881764-3d4af2a1-a8f1-42d5-aee6-90efc7e6db00.png">

## 1. 两个超时的DFS

```python
class Solution:
	def __init__(self):
		self.mod = 10 ** 9 + 7
		
	def checkRecord(self, n):
		return self.dfs(n, 0, 0, 'p', 'p')

	def dfs(self, n, cur_len, a_cnt, prev, prev2):
		if cur_len == n:
			return 1
		res = 0
		# 1. present 随便放
		res += self.dfs(n, cur_len + 1, a_cnt, 'p', prev) % self.mod
		# 2. Absent最多只能放一个
		if a_cnt == 0:
			res += self.dfs(n, cur_len + 1, a_cnt + 1, 'a', prev) % self.mod
		# 3. Late最多连续放2个
		if prev + prev2 != 'll':
			res += self.dfs(n, cur_len + 1, a_cnt, 'l', prev) % self.mod
		return res
```

优化上面的写法： 我们其实不需要记录上两个是什么，只要记录连续的 l 有几个 (`l_cnt`)
只要是 present 和 absent 的情况，就把`l_cnt` 清空为0， 
只要是 late 的情况 `l_cnt` 就 + 1
```python
class Solution:
	def __init__(self):
		self.mod = 10 ** 9 + 7
		
	def checkRecord(self, n):
		return self.dfs(n, 0, 0, 0)

	def dfs(self, n, cur_len, a_cnt, l_cnt):
		if cur_len == n:
			return 1
		res = 0
		res += self.dfs(n, cur_len + 1, a_cnt, 0) % self.mod
		if a_cnt == 0:
			res += self.dfs(n, cur_len + 1, a_cnt + 1, 0) % self.mod
		if l_cnt < 2:
			res += self.dfs(n, cur_len + 1, a_cnt, l_cnt + 1) % self.mod
		return res
```



## 2.  DFS with Memoization (Preferred)

因为每次都会

```python

```





