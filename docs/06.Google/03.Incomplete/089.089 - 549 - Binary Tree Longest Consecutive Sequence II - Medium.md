---
title: 089 - 549 - Binary Tree Longest Consecutive Sequence II - Medium
date: 2022-08-15 11:19:11
permalink: /pages/febfc1/
categories:
  - Google
  - Incomplete
tags:
  - dfs-tree
---
tags: [Tree, Depth-First Search, Binary Tree]

![](https://raw.githubusercontent.com/emmableu/image/master/202208151722177.png)

```
 降序，-1  2 升序，+1
		1    3

2: {root: None, left: -1, right: 1}
1: {root: +1, left: None, right: None}
3: {root: -1, left: None, right: None}
```

## Solution: 一次遍历

在每一个点，我们使用两个变量 incr 和 decr，其中 inc 表示当前点为止最长增长序列的长度（包括该点自己），dec 表示当前点为止最长下降序列的长度（包括该点自己）。

我们使用回溯函数 longestPath(node)，它的函数返回值为 [incr,decr] 这样的形式。我们将 incr 和 decr 在当前点都初始化为 1。这是因为一个点自身总能形成一个长度为 1 的连续上升和下降序列。

然后，我们可以通过调用 longestPath(root.left) 得到左孩子为终点的最长上升或者下降序列。如果左孩子的值比当前值小，那么左孩子与当前节点形成了一个下降序列。因此，当前节点的 decr 值为right_child(decr)+1。  
而如果左孩子的值比当前点的值大，左孩子与当前节点形成一个上升序列，所以我们更新当前点的 incr 值为 left_child(incr)+1

然后，我们对于右孩子也做同样的过程。我们通过取左右孩子对应值的较大值得到当前节点 incr 和 decr 的值。

接下来，在我们得到每个点的 incr 和 decr 的值以后，我们更新当前找到的最长连续路径的长度，maxval=max(incr+decr−1)

