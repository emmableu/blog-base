tags: [Array, Dynamic Programming]

[LC Link](https://leetcode.cn/problems/maximum-number-of-points-with-cost/)

![](https://raw.githubusercontent.com/emmableu/image/master/202207220043952.png)

![](https://raw.githubusercontent.com/emmableu/image/master/202207220048757.png)

## Solution 1: 没有优化的dp, O(MN^2), time limit exceeds
```
dp[r][c] = max(dp[r - 1][prev_c]
			   + points[r][c]
			   - abs(c - prev_c) for prev_c in range(len(points[0)))
```

```python
class Solution:
	def maxPoints(self, points):
		dp = points[0]
		for r in range(1, len(points)):
			cur_row_max = []
			for c, val in enumerate(points[r]):
				max_val = val
				for prev_c, prev_val in enumerate(dp):
					max_val = max(max_val, val + prev_val - abs(c - prev_c))
				cur_row_max.append(max_val)
			dp = cur_row_max
		return max(dp)
```


## Solution 2: preferred
对于上面, 以 `points = [[1,2,3],[1,5,1],[3,1,1]]` 为例

```
[[1,2,3],
 [6,5,4],
 [7,8,9]]
 
dp[0]肯定就是 [1,2,3],
dp[1][0] = max([1 + 6 - 0, 2 + 6 - 1, 3 + 6 - 2])
dp[1][1] = max([1 + 5 - 1, 2 + 5 - 0, 3 + 5 - 1])
dp[1][2] = max([1 + 4 - 2, 2 + 4 - 1, 3 + 4 - 0])
```


Let's say that we start from the top row to the bottom row and pick one number in each row, as requested.  
Suppose we have result array from some previous rows (For example, first **X** rows) as **prev**. Here, **prev[i]** is the total points we have if we pick the **i-th** number in the **X**-th row.

![image](https://assets.leetcode.com/users/images/8cbe8fdc-55c6-4629-9d76-acb88de4aac5_1651327285.2736592.png)

Now we have the **X+1**-th row (points[X + 1]) to pick, what is the result array **curr** for this row according to the previous result array **prev**?  
At a first glance, for the index **i** in **curr**, we have:  
**curr[i] = max(prev[j] - abs(j - i) for j in range(n)) + points[X+1][i]**, but we don't want to literally compare every index in **prev** with every index **i** in **points[X+1]**, which brings O(N ^ 2) time for a single row and O(N ^ 3) for the whole grids.

![image](https://assets.leetcode.com/users/images/1f076567-5fbc-4203-af98-1d463e4722ee_1651327294.0604868.png)

Notice that, for a certain index **i**, the maximum value for **i** is a index that could either come from its left, or its right(inclusive). Thus we can build two arrays, **lft** and **rgt**, and focus on the maximum value only coming from its left or right. Finding the best fit for a single index **i** could just cost O(1) time from then on.

![image](https://assets.leetcode.com/users/images/19088d33-9447-4727-8728-514f0c7f041f_1651327304.4782481.png)

Take a look at how we build **lft**.  
Apparently, **lft[0]** is just **prev[0]**, since there is no other values coming from its left.

![image](https://assets.leetcode.com/users/images/a86e7828-0495-4ab7-a753-f3a0819fe642_1651327321.5416875.png)

For **lft[1]**, we need to make a choice, the value is the larger one between **prev[1]** or **lft[0] - 1**, (considering the index shift so we need to substract **1** from **lft[0]**).

![image](https://assets.leetcode.com/users/images/dee3e134-d5fc-4140-a4d4-43dfd0d0785a_1651327334.5943615.png)

For **lft[2]**, the value is the larger one between **prev[2]** or **lft[1] - 1**, so on so forth.

![image](https://assets.leetcode.com/users/images/2922aa49-05e2-4618-817d-34617be30389_1651327340.3885162.png)

> **Wait a second...**  
> **Why we just compare prev[2] and lft[1] - 1, why its not necessary to compare lft[0] - 2 as well?**

Assume we do compare: **lft[1] - 1** and **lft[0] - 2**, that is, to get `max(lft[2], lft[1] - 1, lft[0] - 2)`  
Add **1** to last two terms and we have: **lft[1]**, **lft[0] - 1**.  
Looks familiar? That is exactly the previous comparison we made for `index=1`, we have already selected the maximum value in the selection on the previous index and saved it in **curr[1]**, shifting all previous candidates by 1 doesn't change the result. We can just safetly use the larger result from the previous index.

Build **rgt** using the same method.

![image](https://assets.leetcode.com/users/images/217aa899-811d-44be-8d85-316e84d23be3_1651327348.3117893.png)

Now for each index **i** in **points[X+1]**, all we need to do is get the larger value from **lft[i], rgt[i]**, plus **points[X+1][i]**, and that is the maximum value **curr[i]** for this current row. Aftering filling **curr**, we could move on to the next row by taking **curr** as **prev**. Therefore, for each new row, we repeatedly get **lft, rgt** from **prev**, get **curr** from **points[X], lft, rgt**, until we reach the last row.

![image](https://assets.leetcode.com/users/images/cbac3d46-47f2-4541-a595-e27b3bf6bf8f_1651327356.6044252.png)

```python
def maxPoints(self, P: List[List[int]]) -> int:
        m, n = len(P), len(P[0])
        if m == 1: return max(P[0])
        if n == 1: return sum(sum(x) for x in P)
        
        def left(arr):
            lft = [arr[0]] + [0] * (n - 1)
            for i in range(1, n): lft[i] = max(lft[i - 1] - 1, arr[i])
            return lft
        
        def right(arr):
            rgt = [0] * (n - 1) + [arr[-1]]
            for i in range(n - 2, -1, -1): rgt[i] = max(rgt[i + 1] - 1, arr[i])
            return rgt
        
        pre = P[0]
        for i in range(m - 1):
            lft, rgt, cur = left(pre), right(pre), [0] * n
            for j in range(n):
                cur[j] = P[i + 1][j] + max(lft[j], rgt[j])
            pre = cur[:]

        return max(pre)
```