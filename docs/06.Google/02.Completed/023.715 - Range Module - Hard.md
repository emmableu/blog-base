---
title: 715-Range Module
date: 2021-10-10 15:33:13
permalink: /pages/583d16/
categories:
  - p5
tags:
  - segment tree
---
[LC link](https://leetcode.cn/problems/range-module/)

<img alt="image" src="https://user-images.githubusercontent.com/41789327/179932958-a45025a7-1148-4afc-ac8f-7870ebd505bc.png">


## Solution 1 (preferred): 线段树 Segment Tree
```python
class SegmentNode:
	def __init__(self):
		self.left = None
		self.right = None
		self.val = 0
		self.add = 0

class RangeModule:
	def __init__(self):

	def addRange(self, left, right):

	def queryRange(self, left, right):

	def removeRange(self, left, right):
```

## Solution 2
以example中的
```
input:
["RangeModule", "addRange", "removeRange", "queryRange", "queryRange", "queryRange"]
[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]
```
为例:

用一个`track`来保留每次的范围， 
- 初始化为`[]`
- `addRange(10,20)`以后得到 `track = [10, 20]`, 表示valid区间 `[10, 20)` (注意开闭)
- `removeRange(14,16)`以后得到 `track = [10, 14, 16, 20]`, 表示valid区间 `[10, 14), [16, 20)`(注意开闭)


`addRange(left, right)`: 
- 得到 left， right，要插入的话对应的index `start`, `end`，如果有一样的话left要尽量靠左，right要尽量靠右，
- `self.track[start:end] = subtrack`, 如果 `start == end` 就是直接插入，否则的话就是替换现有的部分数组
- `subtrack` 里面可能不包含 left， right ，取决于这个点：
  - 在 `track=[10,20,30,40]` 中`addRange(21, 35)`就是得到 `subtrack=[21]`,`track=[10,20,21,40]`
  - 其实就是left，right，分别只有在是**偶数**的时候才能放进subtrack


`removeRange(left, right)`: 
- 得到 left， right，要插入的话对应的index `start`, `end`，如果有一样的话left要尽量靠左，right要尽量靠右，
- `self.track[start:end] = subtrack`, 如果 `start == end` 就是直接插入，否则的话就是替换现有的部分数组
- `subtrack` 里面可能不包含 left， right ，取决于这个点：
  - 在 `track=[10,20,30,40]` 中`removeRange(21, 35)`就是得到 `subtrack=[35]`,`track=[10, 20, 35, 40]`
  - 其实就是left，right，分别只有在是**奇数**的时候才能放进subtrack


`queryRange(left, right)`: 
- 得到 left， right，要插入的话对应的index `start`, `end`，如果有一样的话left要尽量靠左，right要尽量靠右，
- start 必须 == end，且 是奇数 这样才是插入一个现有的区间内， 
- 比如在 track=[10,20,30,40] 里面，
  - 如果是`queryRange(11, 12)`, 则 `start == end == 1`, 返回true
  - 如果是`queryRange(21, 22)`, 则 `start == end == 2`, 返回false



### APIs
#### bisect
```python
bisect.bisect_left(list, item[, lo[, hi]])
```
返回最左可以insert的点， 比如`bisect.bisect_left([0,1,2,2,2], 2)` 返回`2`.

```python
bisect.bisect_right(list, item[, lo[, hi]])
```
返回最右可以insert的点， 比如`bisect.bisect_right([0,1,2,2,2], 2)` 返回`5`.

#### 数组中插入数组 arr[2:2] = [2.5]
```
arr = [0,1,2,3,4,5]
arr[2:2] = [2.5]
print(arr)
```
得到 `[0,1,2,2.5,3,4,5]`

但是如果是
```
arr = [0,1,2,3,4,5]
arr[2:3] = [2.5]
print(arr)
```
则得到 `[0,1,2.5,3,4,5]`

### Code
```python
import bisect

class RangeModule:

    def __init__(self):
        self.track = []

    def addRange(self, left, right):
        start = bisect.bisect_left(self.track, left)
        end = bisect.bisect_right(self.track, right)
        
        subtrack = []
        # start为偶数的时候才能直接放left，因为偶数表示在一个现有的valid range之外，
        # 比如21 对于[10,20,30,40]
        if start % 2 == 0:
            subtrack.append(left)
        if end % 2 == 0:
            subtrack.append(right)
			
        self.track[start:end] = subtrack

    def removeRange(self, left, right):
        start = bisect.bisect_left(self.track, left)
        end = bisect.bisect_right(self.track, right)
        
        subtrack = []
        if start % 2 == 1:
            subtrack.append(left)
        if end % 2 == 1:
            subtrack.append(right)
			
        self.track[start:end] = subtrack
		
    def queryRange(self, left, right):
        start = bisect.bisect_right(self.track, left)
        end = bisect.bisect_left(self.track, right)
		
        return start == end and start % 2 == 1
```
