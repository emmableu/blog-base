---
title: 470 - 238 - Product of Array Except Self
date: 2021-08-10 12:30:44
permalink: /pages/f75c0d/
categories:
  - 
tags:
  - prefix sum
  - two pointer
---

## Description:
Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.

Example 1:
```
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
```

Example 2:
```
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0] 
```

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)


Constraints:

- 2 <= nums.length <= 105
- -30 <= nums[i] <= 30
- The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.


## solutionï¼š
`[1, 2, 3, 4]`
- prefix_product:` [1, 1, 2, 6] `  ----> this is the product of the left of the element
    `p[i] = p[i-1]*nums[i-1]`
- suffix_product:`[24, 12, 4, 1]` ----> this is the product of the right of the element
    `s[i] = s[i+1]*nums[i+1]`

- the above is essentially O(n) space complexity.
- To change that to O(1) space complexity: change results based on prefix_product

suffix_product (now is a number) = 1, 4, 12, ...


```python
class Solution:
    def productExceptSelf(self, nums):
        res = [1]
        for i in range(len(nums)-1):
            res.append(res[-1]*nums[i])
        suffix_product = 1
        for i in range(len(res)-2, -1, -1):
            suffix_product = nums[i+1] * suffix_product
            res[i] = res[i]*suffix_product
        return res
```
