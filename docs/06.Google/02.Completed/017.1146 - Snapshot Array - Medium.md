---
title: 1146 - Snapshot Array - Medium
date: 2022-07-27 09:57:26
permalink: /pages/890177/
categories:
  - Google
  - Completed
tags:
  - 
---
tags: [Array, Hash Table, Binary Search, Design]

[LC link](https://leetcode.cn/problems/snapshot-array/)
<img width="698" alt="image" src="https://user-images.githubusercontent.com/41789327/180663794-6387c8ff-fe34-4e55-ad72-3fe4642571f4.png">
## Solution
[reference](https://leetcode.com/problems/snapshot-array/discuss/350562/JavaPython-Binary-Search)

记录每个cell 的历史， 就是每个snap_id 对应的值
然后用get取这个cell在某个snap_id的值的时候，就用binary_search找到对应的时间点

**Complexity**
Time `O(logS)`  
Space `O(S)`  
where `S` is the number of `set` called.

`SnapshotArray(int length)` is `O(N)` time  
`set(int index, int val)` is O(1) in Python and `O(logSnap)` in Java  
`snap()` is `O(1)`  
`get(int index, int snap_id)` is `O(logSnap)`

| input                          | self.sid | self.arr                                            | return |
| ------------------------------ | -------- | --------------------------------------------------- | ------ |
| snapshotArr = SnapshotArray(3) | 0        | `[[[-1, 0]], [[-1, 0]], [[-1,0]]]`                  | None   |
| snapshotArr.set(0, 5)          | 0        | `[[[-1, 0], [0, 5]], [[-1, 0]], [[-1, 0]]]`         | None   |
| snapshotArr.snap()             | 1        | `[[[-1, 0], [0, 5]], [[-1, 0]], [[-1, 0]]]`         | 0      |
| snapshotArr.set(0, 6)          | 1        | `[[[-1, 0], [0, 5], [1, 6]], [[-1, 0]], [[-1, 0]]]` | None   |
| snapshotArr.get(0, 0)          | 1        |      `[[[-1, 0], [0, 5], [1, 6]], [[-1, 0]], [[-1, 0]]]`                                             |5        |


为什么用二分搜索要比较`self.arr[index][0]`  和`sid`, 而不是比较 `self.arr[index]`和 `[sid]`: 
- 因为list之间可以比较大小要看第二个元素， 见下图。而我们希望的比较方式是  希望 【0】 和 【0， 1】 能是相等的 （这样可以用二分搜索查找上界的模版）。 
<img width="555" alt="image" src="https://user-images.githubusercontent.com/41789327/180695696-8d94d834-7e95-404d-81f4-b9f1493d27c5.png">
**Note:  二分搜索查找上界 或 查找离他最近且<=他的元素的index**  [模版link](https://emmableu.github.io/blog/pages/fb7263/#_2-%E6%9F%A5%E6%89%BE%E4%B8%8A%E7%95%8C-%E6%88%96-%E6%9F%A5%E6%89%BE%E7%A6%BB%E4%BB%96%E6%9C%80%E8%BF%91%E4%B8%94-%E4%BB%96%E7%9A%84%E5%85%83%E7%B4%A0%E7%9A%84index)
- *不能*用于查找插入位置，(**和 `bisect.bisect_right` 是不一样的**)
- 查找上界：[Search for a Range](https://leetcode.com/problems/search-for-a-range/) 和 [Find First and Last Position of Element](https://emmableu.github.io/blog/pages/fd77d2)
- 查找离他最近且<=他的元素：[divide two integers](https://emmableu.github.io/blog/pages/489c53/)
比如： 
- `nums = [0,1,2,3,4,4,5], target = 4`, 返回5
- `nums = [0,1,2,3,4,4,5], target = 10`, 返回6
- `nums = [0,1,2,3,4,4,5], target = 3.5` 返回3 <- 就是这个和bisect_right 不一样
- `nums = [0,1,2,3,4,4,5], target = 0` 返回0
- `nums = [0,1,2,3,4,4,5], target = -1` 返回-1
target < nums[0] 时会返回 -1

```python
def search(nums, target):
    l, r = -1, len(nums)
    while l + 1 < r:
        mid = (l + r) >> 1
        if nums[mid] <= target: #f(mid) <= target
            l = mid
        else:
            r = mid
    return r - 1
```


```python
class SnapshotArray:

	def __init__(self, n):
		self.arr = [[[-1, 0]] for _ in range(n)]
		self.sid = 0

	def set(self, index, val):
		self.arr[index].append([self.sid, val])

	def snap(self):
		self.sid += 1
		return self.sid - 1

	def get(self, index, sid):
		l, r = -1, len(self.arr[index])
		while l + 1 < r:
			mid = (l + r) // 2
			if self.arr[index][mid][0] <= sid:
				l = mid
			else:
				r = mid 
		return self.arr[index][r-1][1]
```