---
title: 843-Guess the Word
date: 2021-11-02 19:09:27
permalink: /pages/88dc22/
categories:
  - leetcode
  - leetcode problems
tags:
  - 
---

![](https://raw.githubusercontent.com/emmableu/image/master/843-0.png)
## Solution:
1. **Clarify**

Does the algorithm I design have to find the secret word within 10 times of guesses? The answer is No, you only need to design an algorithm that can find the secret word in as less times as possible.

2. **Idea**

Because if we find the secret word after 10 times of calling `master.guess()`, we fail the test case, *let's call `master.guess()` 10 times or until we find the secret word, whichever comes first*.

Because there is no guanrantee that we can find the secret word within 10 calls, now our goal is to design a algorithm to find the secret word in as less times of calling `master.guess()` as possible.

How to find the secret word in as less times of calling master.guess() as possible? The answer is *trying to narrow the candidates after each time we call master.guess()*

For now, the structure of our algorithm is:
```
//pseudocode version 1
for(int i = 0, matches = 0; i < 10 && matches != 6; i ++){
	matches = master.guess(a word in candidate);
	reduce the number of words in candidate
}
```
**How to narrow the candidates?**   

we have `x = master.guess(word)`
- if `x == 6`, we find the secret word, the algorithm ends
- if `x != 6`, it means secret has exactly x matches with word

Because secret has exactly x matches with word, we can just search in the candidates, and **only keep the ones that have exact x matches with word**. In this way, we narrow the candidates after we call master.guess(), and guarantee that secret is in candidates left.

For now, the structure of our algorithm is changed to
```
//pseudocode version 2
for(int i = 0, matches = 0; i < 10 && matches != 6; i ++){
	matches = master.guess(a word in candidates);

	for(String candidate: candidates){
		if(matches == getMatches(candidate, word)){
			tempCandidates.add(candidate);
		}
	}

	candidates = tempCandidates;
```
So we need a helper method to check the number of matches between two words:
```
int getMatches(String word1, String word2){
	int matches = 0;
	for(int i = 0; i < 6; i ++){
		if(word1.charAt(i) == word2.charAt(i)){
			matches ++;
		}
	}
}
```
Now the key problem is **how to select word in candidates as the input of master.guess()**?
We have two options:
- option-1: select the first candidate as the input of master.guess() every time
- option-2: randomly select one word from candidates as the input of master.guess()
Which is better? The analysis is below:




