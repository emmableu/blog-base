---
title: 778-Swim in Rising Water
date: 2021-09-21 15:33:13
permalink: /pages/c2e0c3/
categories:

tags:
  - 网格bfs
  - heap
---
[LC link](https://leetcode.com/problems/swim-in-rising-water/)

![](https://raw.githubusercontent.com/emmableu/image/master/778-0.png)

## solution:  BFS + priority queue

### 策略1: 每次都走**当前点的周围**水位最低的点 （不行）
但是这会有问题：当某个点的周围最小的点对应的路径可能反而是比较大的，比如：
```
0 1 4
2 8 7
3 6 5
```
有两条路径
- start -> 1 -> 4 -> 7 -> end, 这个遵从了策略1，但是最后返回7
- start -> 2 -> 3 -> 6 -> end， 这个遵从了下面的策略2， 返回6， 比上面的方法更好。 
### 策略2: 每次都瞬移到**所有点**中水位最低的点 （行）


根据 [BFS模版](https://emmableu.github.io/blog/pages/8b354b/#_1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86)：
- queue里面存的是临时（在下一层bfs里面）要用的变量
- vis里面存的是全局一直要用的变量

## 需要定义的变量：
- `q`, 定义的是每次临时要用的变量，这里用一个heapq来保存剩下没走过的点的高度
- `vis` 定义的是全局要用的帮助filter的变量，这里记录走过的点的 (r, c) 值 （对python来说，把这个写成一个 {(r, c)} 的set，比用一个matrix，然后在上面计走没走过（1/0）似乎更快，虽然都是 o(1)）


```
void BFS()
{
    判断边界条件，是否能直接返回结果的。： 本题如果长宽最少是2，所以应该没问题

    定义队列，其中有一个元素是起始位置： 本题的队列比较特殊，初始化的时候

    定义备忘录(visited)，用于记录已经访问的位置，其中有一个元素是起始位置： vis 用一个 matrix表示，

    初始化step = 0,根据在哪里返回step，step也可能初始化为-1

    while (队列不为空) {
        获取当前队列中的元素个数。 size = len(q)
        step += 1
        for (元素个数) {
            取出一个位置节点。(e.g., ele = q.popleft())    r, c, obs = q.popleft()
            获取它对应的下一个所有的节点。 for x, y in (r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1):
            如果当前扩散结果 == target: （x == m - 1 and y == n - 1）
                return step
            如果当前扩散结果 not in vis:
                                           new_obs = obs + grid[x][y]
                过滤
                                      if not (0 <= x < m and 0 <= y < n):
                                          continue
                                      if new_obs >= vis[x][y]:
                                          continue 
                当前的扩散结果加入temp。  q.append((x, y, new_obs))
                visited.add()           vis[x][y] = new_obs 
        }
    }
    返回 (如果是search，则可能是返回-1) return -1
}

```

```python
import heapq
class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        q = [(grid[0][0], 0, 0)]
        vis = {(0, 0)}
        res = 0 # 因为grid中的元素最小为0，所以res初始化为0就好
        while True:
            cap, r, c = heapq.heappop(q)
            res = max(res, cap)
            if r == len(grid) - 1 and c == len(grid[0]) - 1:
                return res
            for x, y in (r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1):
                if self.in_area(grid, x, y) and (x, y) not in vis:
                    heapq.heappush(q, (grid[x][y], x, y))
                    vis.add((x, y))
          
    def in_area(self, grid, r, c):
        return 0 <= r < len(grid) and 0 <= c < len(grid[0])
```

time complexity: `O((n^2)*logn)`

- pq contains at most n^2 elements, pop time complexity each time is is O(log(n^2)) = O(2*logn)
- At most we will pop n^2 times
`O((n^2)*2*logn) = O((n^2)*logn)`
