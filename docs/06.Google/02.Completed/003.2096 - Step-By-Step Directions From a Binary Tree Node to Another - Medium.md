tags: [String, Tree, Depth-First Search, Binary Tree]

[LC Link](https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/)


<img width="767" alt="image" src="https://user-images.githubusercontent.com/41789327/178127867-3ba842a0-2616-48d7-95f8-4634704cb316.png">
<img width="783" alt="image" src="https://user-images.githubusercontent.com/41789327/178127873-a9d55b66-3385-442e-ba5d-7b5443223b92.png">


1.  Build directions for both start and destination from the root.
    -   Say we get "LLRRL" and "LRR".
2.  Remove common prefix path.
    -   We remove "L", and now start direction is "LRRL", and destination - "RR"
3.  Replace all steps in the start direction to "U" and add destination direction.
    -   The result is "UUUU" + "RR".

```python
class Solution:
    def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
        def dfs(self, root, target, cur_path):
	        if not root:
		        return False
		    if root.val == target:
			    return True
	        in_left = self.dfs(root.left, cur_path)
	        in_right = self.dfs(root.right, cur_path)
	        if in_left:
		        cur_path.append("L")
		        return True
		    if in_right:
			    cur_path.append("R")
			    return True
			return False
		start_to_root, dest_to_root = [], []
		self.dfs(root, startValue, start_to_root)
		self.dfs(root, destValue, dest_to_root)
		while start_to_root and dest_to_root and start_to_root[-1] == dest_to_root[-1]:
			start_to_root.pop()
			dest_to_root.pop()
		return "".join(start_to_root) + "".join(dest_to_root[::-1])
```