---
title: 431 - 22-Generate Parentheses
date: 2021-12-13 15:33:13
permalink: /pages/327e8a/
categories:
  

tags:
  - 
---
[LC link](https://leetcode.com/problems/generate-parentheses/)

Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

Example 1:
```
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
```
Example 2:
```
Input: n = 1
Output: ["()"]
```

Constraints:
- 1 <= n <= 8

## Solution: DFS
以`n = 2`为例，下面为树形结构图，方法为【做减法】：

![](https://raw.githubusercontent.com/emmableu/image/master/22-0.png)

画图以后，可以分析出的结论：

- 当前左右括号都有大于 0 个可以使用的时候，才产生分支；
- 产生左分支的时候，只看当前是否还有左括号可以使用；
- **(最重要)产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；**, 也就是说，出现这种情况"())))"时，直接可以淘汰这个candidate。
- 在左边和右边剩余的括号数都等于 0 的时候结算。

### Python 
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        res = []
        cur_str = ''

        def dfs(cur_str, left, right):
            """
            :param cur_str: 从根结点到叶子结点的路径字符串
            :param left: 左括号还可以使用的个数
            :param right: 右括号还可以使用的个数
            :return:
            """
            if left == 0 and right == 0:
                res.append(cur_str)
                return
            # 右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支
            if right < left:
                return
            if left > 0:
                dfs(cur_str + '(', left - 1, right)
            if right > 0:
                dfs(cur_str + ')', left, right - 1)

        dfs(cur_str, n, n)
        return res
```

### Java
```java
class Solution {
    
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        String cur = "";
        dfs(res, cur, n, n);
        return res;
    }

    void dfs(List<String> res, String cur, int left, int right) {
        if (left == 0 && right == 0) {
            res.add(cur);
            return;
        }
        if (right < left) {
            return;
        }
        if (left > 0) {
            dfs(res, cur + "(", left - 1, right);
        }
        if (right > 0) {
            dfs(res, cur + ")", left, right - 1);
        }
    }
}
```
