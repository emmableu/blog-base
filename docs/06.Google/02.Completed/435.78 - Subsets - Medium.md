---
title: 78 - Subsets
date: 2021-08-10 23:59:00
permalink: /pages/leetcode78
categories:
  - 
tags:
  - dfs
  
  - 近期面经
---
## Description:

Given an integer array nums of unique elements, return all possible subsets (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.

 
```
Example 1:

Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]


Example 2:

Input: nums = [0]
Output: [[],[0]]
``` 

Constraints:

- 1 <= nums.length <= 10
- -10 <= nums[i] <= 10
- All the numbers of nums are unique.

## Method： backtrack
在每一次循环中，固定前面的值不变，然后可以选择把下一个num append到当前的结果（cur）里面，也可以选择不append，  
所以就是append进去，然后等它相关的递归结束后，再pop出来，做不append的时候要做的循环  
树结构:
```
[]
    [1]
        [12]
            [123]
        [13]
    [2]
        [23] 
```

## 注意：
- res初定义的时候，应该是一个空的，不需要pre-populate一个空数组进去 （是 `[]`, not `[[]]`)

```python
import copy
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:

        def dfs(i, cur):
            nonlocal res
            res.append(copy.deepcopy(cur))
            if i == len(nums):
                return
            for j in range(i, len(nums)):
                cur.append(nums[j])
                dfs(j+1, cur)
                cur.pop()

        res = []
        dfs(0, [])
        return res
```