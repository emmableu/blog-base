---
title: 162 - 315 - Count of Smaller Numbers After Self - Hard
date: 2022-07-27 09:57:21
permalink: /pages/2a07fa/
categories:
  - Google
  - Completed
tags:
  - merge sort
---

[LC Link](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

![](https://raw.githubusercontent.com/emmableu/image/master/202208291433156.png)
![](https://raw.githubusercontent.com/emmableu/image/master/202208291433774.png)


先看[归并排序算法](/pages/5d7c1e/#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF), 后面会引用到这个算法的merge方法


拍脑袋的暴力解法就不说了，嵌套 for 循环，平方级别的复杂度。

这题和归并排序什么关系呢，主要在`merge`函数，我们在合并两个有序数组的时候，其实是可以知道一个数字`x`后边有多少个数字比`x`小的。

具体来说，比如这个场景：
![](https://raw.githubusercontent.com/emmableu/image/master/202208291435537.png)

这时候我们应该把`temp[i]`放到`nums[p]`上，因为`temp[i] < temp[j]`。

但就在这个场景下，我们还可以知道一个信息：5 后面比 5 小的元素个数就是`[mid + 1, j)` (左闭右开) 之间的元素个数，即 2 个。

![](https://raw.githubusercontent.com/emmableu/image/master/202208291437380.png)


**换句话说，在对`nuns[lo..hi]`合并的过程中，每当执行`nums[p] = temp[i]`时，就可以确定`temp[i]`这个元素后面比它小的元素个数为`j - mid - 1`**。

当然，`nums[lo..hi]`本身也只是一个子数组，这个子数组之后还会被执行`merge`，其中元素的位置还是会改变。但这是其他递归节点需要考虑的问题，我们只要在`merge`函数中做一些手脚，就可以让每个递归节点叠加每次`merge`时记录的结果。

发现了这个规律后，我们只要在`merge`中添加两行代码即可解决这个问题，看解法代码：
```python
class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
		self.tmp = [0] * len(nums)
		
	def merge(self, nums, lo, mid, hi):
		
```