---
title: 048 - 1631 - Path With Minimum Effort - Medium
date: 2022-07-27 09:57:26
permalink: /pages/4197de/
categories:
  - Google
  - Incomplete
tags:
  - 
---
tags: [Array, Binary Search, Depth-First Search, Breadth-First Search, Union Find, Heap (Priority Queue), Matrix]


[LC Link](https://leetcode.cn/problems/path-with-minimum-effort/)

![](https://raw.githubusercontent.com/emmableu/image/master/202208110030641.png)
![](https://raw.githubusercontent.com/emmableu/image/master/202208110030296.png)


## Solution: Dijkstra + Binary Search

shortest path problem: 本题实际就是找从出发点(0, 0)到终点(m - 1, n - 1) 路程最短的path

这里, total path cost = maximum absolute difference in heights between two consecutive cells of the path. 


**注意：** vis 要设置成 (cur_dist, x, y), 而不是像  [778-Swim in Rising Water](/pages/c2e0c3/) 一样设置成 (x, y), 因为从不同的出发点到同一个格点 (x, y) 需要的 dist不一样。 

```python
import heapq

class Solution:
	def minimumEffortPath(self, heights: List[List[int]]) -> int:
		m, n = len(heights), len(heights[0])
		dist = [[float('inf') for j in range(n)] for i in range(m)]
		q = [(0, 0, 0)] # dist, row, col
		vis = {(0, 0, 0)}
		max_dist = 0
		while True:
			dist, r, c = heapq.heappop(q)
			max_dist = max(max_dist, dist)
			if r == m - 1 and c == n - 1:
				return max_dist
			for x, y in (r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1):
				if 0 <= x < m and 0 <= y < n:
					cur_dist = abs(heights[x][y] - heights[r][c])
					if (cur_dist, x, y) not in vis:
						heapq.heappush(q, (cur_dist, x, y))
						vis.add((cur_dist, x, y))
```