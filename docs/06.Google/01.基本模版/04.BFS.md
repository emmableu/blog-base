---
title: 广度优先搜索 BFS 模版
date: 2021-10-03 22:29:14
permalink: /pages/8b354b/
categories:
  
  - 基本模版
tags:
  - bfs
---
## 单向bfs
### 1.层序遍历
```
void BFS()
{
    判断边界条件，是否能直接返回结果的。

    定义队列，其中有一个元素是起始位置

    定义备忘录(visited)，用于记录已经访问的位置，其中有一个元素是起始位置

    初始化step = 0,根据在哪里返回step，step也可能初始化为-1

    while (队列不为空) {
        获取当前队列中的元素个数。
        step += 1
        for (元素个数) {
            取出一个位置节点。(e.g., ele = q.popleft())
            # (一般来说写在扩散过程中) 判断是否到达终点位置, 如果是，返回 step 
            获取它对应的下一个所有的节点。
            如果当前扩散结果 == target:
                return step
            如果当前扩散结果 not in vis:
                过滤
                当前的扩散结果加入temp。
                visited.add() 
        }
    }
    返回 (如果是search，则可能是返回-1)
}
```
## bfs中对扩散结果进行过滤的几个常见判断条件：
- 是否在vis里面
- 是否在界内 （尤其是网格bfs）
- 是否是一个障碍物 （例如shortest distance 和推箱子题）

#### 注意：
- 如果是每一个step要遍历多个元素，那么往往是 while q, 例如 [1293 - Shortest Path in a Grid with Obstacles Elimination](/pages/0128c7/)
- 如果是每一个step遍历一个元素，那么有的时候 while true 就行了，例如两个dijkstra 算法题：
	- [778-Swim in Rising Water](/pages/c2e0c3/) 要用heapq
	- [1631 - Path With Minimum Effort](/pages/4197de/) vis标记要注意不仅仅是x，y坐标


## 双向bfs
### 最短距离：把queue改成hashset来判断两个集合是否有交集
- 遍历前，判断 len(q1 & q2) 是否 > 0 (if q1 & q2)
- 每次遍历：把q1,q2中短的那个叫做q1，只遍历q1
- 遍历的最后：把当前的扩散结果(temp)赋值给q1

相关题：
- [word ladder](https://emmableu.github.io/blog/pages/ea20ba/)
- [minimum knight moves](https://emmableu.github.io/blog/pages/a4eef7)
- [labuladong的模版](https://labuladong.gitbook.io/algo/mu-lu-ye/bfs-kuang-jia)
```python
def bfs():
    q1 = set([起始点])
    q2 = set([target位置])
    if q1 & q2:
        return 0
    vis = set([起始点，target位置]) # visited
        or: vis = q1 | q2
    step = 0

    while q1 and q2:
        # 哈希集合在遍历过程中不能修改，用temp存储扩散结果
        if len(q1) > len(q2):
            q2, q1 = q1, q2
        temp = set()
        step += 1 
        for cur in q1:
            获取它对应的下一个所有的节点。
            如果当前扩散结果 in q2:
                return step
            如果当前扩散结果 not in vis:
                当前的扩散结果加入temp。
                visited.add() 
        
        q1 = temp
```

## 注意：
以下的写法会报错：
```python
a = {}; a.add(1)
```
但是, 下面两种都是对的
```python
a = set(); a.add(1)
a = {2}; a.add(1)
```
