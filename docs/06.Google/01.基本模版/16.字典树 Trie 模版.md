Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。

本文主要分三部分：

**1、讲解 Trie 树的工作原理**。

**2、给出一套`TrieMap`和`TrieSet`的代码模板，实现几个常用 API**。

**3、实践环节，直接套代码模板秒杀 5 道算法题**。

关于`Map`和`Set`，是两个抽象数据结构（接口），`Map`存储一个键值对集合，其中键不重复，`Set`存储一个不重复的元素集合。

而本文实现的 TrieSet/TrieMap 底层则用 Trie 树这种结构来实现。

了解数据结构的读者应该知道，本质上`Set`可以视为一种特殊的`Map`，`Set`其实就是`Map`中的键。

**所以本文先实现`TrieMap`，然后在`TrieMap`的基础上封装出`TrieSet`**。

> PS：为了模板通用性的考虑，后文会用到 Java 的泛型，也就是用尖括号`<>`指定的类型变量。这些类型变量的作用是指定我们实现的容器中存储的数据类型，类比 Java 标准库的那些容器的用法应该不难理解。

前文 [学习数据结构的框架思维](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484852&idx=1&sn=85b50b8b0470bb4897e517955f4e5002&scene=21#wechat_redirect) 说过，各种乱七八糟的结构都是为了在「特定场景」下尽可能高效地进行增删查改。

你比如`HashMap<K, V>`的优势是能够在 O(1) 时间通过键查找对应的值，但要求键的类型`K`必须是「可哈希」的；而`TreeMap<K, V>`的特点是方便根据键的大小进行操作，但要求键的类型`K`必须是「可比较」的。

本文要实现的`TrieMap`也是类似的，由于 Trie 树原理，我们要求`TrieMap<V>`的键必须是字符串类型，值的类型`V`可以随意。

接下来我们了解一下 Trie 树的原理，看看为什么这种数据结构能够高效操作字符串。

### Trie 树原理

**Trie 树本质上就是一棵从二叉树衍生出来的多叉树**。

二叉树节点的代码实现是这样：

```python
class TreeNode:
	def __init__(self, val, left=None, right=None):
		self.val = val
		self.left = left
		self.right = right
```

其中`left, right`存储左右子节点的指针，所以二叉树的结构是这样：

![Image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdHbPt3iaYMdmqUMxEpq0F5AMtSNiayZaWQxGGmNVWsor8p6cUPXNpnWpiadmoTtModFQx5o0OuG1Voibw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

多叉树节点的代码实现是这样：

```python
# 基本的多叉树节点
class TreeNode:
	def __init__(self, val):
		self.val = val
		self.children = []
```

其中`children`数组中存储指向孩子节点的指针，所以多叉树的结构是这样：

![Image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdHbPt3iaYMdmqUMxEpq0F5AMjhw1tYsxxAsqevvZ1JibAt8CaWwjzPwbaowydwMYSKCics1lmibsAPsBw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

而`TrieMap`中的树节点`TrieNode`的代码实现是这样：

```python
# Trie 树节点实现
class TrieNode:
	def __init__(self):
		self.val = None
		self.children = {}
		
```

这个`val`字段存储键对应的值，`children`数组存储指向子节点的指针。

比如说`children['a']`如果非空，说明这里存储了一个字符`'a'`

有了以上铺垫，Trie 树的结构是这样的：

![Image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdHbPt3iaYMdmqUMxEpq0F5AMqngdeqiaUYJ39ExKr5Sk4OyeTiap1KLDH38ib9WMYZTrMRamDIFVxgI9g/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

这是在`TrieMap`中插入一些键值对后的样子，白色节点代表`val`字段为空，橙色节点代表`val`字段非空。

**这里要特别注意，`TrieNode`节点本身只存储`val`字段，并没有一个字段来存储字符，字符是通过子节点在父节点的`children`数组中的索引确定的**。

**形象理解就是，Trie 树用「树枝」存储字符串（键），用「节点」存储字符串（键）对应的数据（值）。所以我在图中把字符标在树枝，键对应的值`val`标在节点上**：

![Image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdHbPt3iaYMdmqUMxEpq0F5AMuKFmpJEB0gM7FJuVjAicfIoWB7HtdISJ18bcqKfwlnibeth3ZibVD35Sg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

明白这一点很重要，有助于之后你理解代码实现。

> PS：《算法 4》以及网上讲 Trie 树的很多文章中都是把字符标在节点上，我认为这样很容易让初学者产生误解，所以建议大家按照我的这种理解来记忆 Trie 树结构。

现在你应该知道为啥 Trie 树也叫前缀树了，因为其中的字符串共享前缀，相同前缀的字符串集中在 Trie 树中的一个子树上，给字符串的处理带来很大的便利。

### TrieMap/TrieSet API 及实现

首先我们看一下本文实现的`TrieMap`的 API，为了举例 API 的功能，假设 TrieMap 中已经存储了如下键值对：

![Image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdHbPt3iaYMdmqUMxEpq0F5AMqngdeqiaUYJ39ExKr5Sk4OyeTiap1KLDH38ib9WMYZTrMRamDIFVxgI9g/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

```python
# 底层用 Trie 树实现的键值映射
# 键为 String 类型，值为类型 V
class TrieMap:

	"""在 Map 中添加 key"""
	def put(self, key: str, val: V) -> None: 

	"""删除键 key 以及对应的值"""
	def remove(self, key: str) -> None: 

	"""搜索 key 对应的值，不存在则返回 None
       get("the") -> 4  
       get("tha") -> None"""
	def get(self, key: str) -> V: 

	"""判断 key 是否存在在 Map 中
	   contains_key("tea") -> False
	   contains_key("team") -> True"""
	def contains_key(self, key: str) -> bool:

	"""在 Map 的所有键中搜索 query 的最短前缀
		shortest_prefix_of("themxyz") -> "the" """
	def shortest_prefix_of(self, query: str) -> str:

	"""在 Map 的所有键中搜索 query 的最长前缀
	   longest_prefix_of("themxyz") -> "them" """
	def longest_prefix_of(self, query: str) -> str:

	"""搜索所有前缀为 prefix 的键
		keys_with_prefix("th") -> ["that", "the", "them"] """
	def keys_with_prefix(self, prefix: str) -> list:

	"""判断是否存在前缀为 prefix 的键
	   has_key_with_prefix("tha") -> true, 因为有 that
	   has_key_with_prefix("apple") -> false """
	def has_key_with_prefix(self, prefix: str) -> bool:

	"""通配符 . 匹配任意字符，搜索所有匹配的键
	   keys_with_pattern("t.a.") -> ["team", "that"]"""
	def keys_with_pattern(self, pattern: str) -> list:

	"""通配符 . 匹配任意字符，判断是否存在匹配的键
		hasKeyWithPattern(".ip") -> true
		hasKeyWithPattern(".i") -> false"""
	def has_key_with_pattern(self, pattern: str) -> bool:

	"""返回 Map 中键值对的数量"""
	def size(self) -> int:
```


至于`TrieSet`的 API 大同小异，所以这里不重复列举，后文直接给出实现。

**接下来是重头戏，我们一个一个实现`TrieMap`的上述 API 函数**。

首先，`TrieMap`类中一定需要记录 Trie 的根节点`root`，以及 Trie 树中的所有节点数量用于实现`size()`方法：
```python
class TrieMap:
	def __init__(self):
		self.size = 0
		self.root = None
	def size(self):
		return self.size
```

另外，我们再实现一个工具函数`get_node`：

```python
# 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null
def get_node(self, node: TrieNode, key: str) -> TrieNode:
	p = node
	for i, c in enumerate(key):
		if p is None:
			return None
		p = p.children[c]
	return p
```

![Image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdHbPt3iaYMdmqUMxEpq0F5AMasVyOONx73VNPuvPPV9SNDj5M3J2Pa7tWMS10bTG2lEQctsxtVVgRA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

有了这个`getNode`函数，就能实现`containsKey`方法和`get`方法了：
```python	
"""搜索 key 对应的值，不存在则返回 None
   get("the") -> 4  
   get("tha") -> None"""
def get(self, key: str) -> V: 
	x = self.get_node(self.root, key)
	if x is None or x.val is None: 
		return None
	return x.val

"""判断 key 是否存在在 Map 中
   contains_key("tea") -> False
   contains_key("team") -> True"""
def contains_key(self, key: str) -> bool:
	return self.get(key) != None
```

**这里需要注意，就算`getNode(key)`的返回值`x`非空，也只能说字符串`key`是一个「前缀」；除非`x.val`同时非空，才能判断键`key`存在**。

不过，这个特性恰好能够帮我们实现`hasKeyWithPrefix`方法：
```python	
"""判断是否存在前缀为 prefix 的键
   has_key_with_prefix("tha") -> true, 因为有 that
   has_key_with_prefix("apple") -> false """
def has_key_with_prefix(self, prefix: str) -> bool:
	return self.get_node(self.root, prefix) is not None
```

类似`getNode`方法的逻辑，我们可以实现`shortestPrefixOf`方法，只要在第一次遇到存有`val`的节点的时候返回就行了：

```python
"""在 Map 的所有键中搜索 query 的最短前缀
	shortest_prefix_of("themxyz") -> "the" """
def shortest_prefix_of(self, query: str) -> str:
	p = self.root
	for i, c in enumerate(query):
		if p is None: #  无法向下搜索
			return ""
		if p.val is not None: # 找到一个键是 query 的前缀
			# 注意到 :i 就可以了，原因见上面的图，字母是在edge上的
			return query[:i]
		p = p.children[c]
	if p is not None and p.val is not None:
		# 如果query 本身就是一个键
		return query
	return ""
```
注意，这个其实是一个深度优先的搜索，但是因为只有一条路径，所以可以用上面的方法解决，而不需要用递归。


**这里需要注意的是 for 循环结束之后我们还需要额外检查一下**。

因为之前说了 Trie 树中「树枝」存储字符串，「节点」存储字符串对应的值，for 循环相当于只遍历了「树枝」，但漏掉了最后一个「节点」，即`query`本身就是`TrieMap`中的一个键的情况。

如果你理解了`shortestPrefixOf`的实现，那么`longestPrefixOf`也是非常类似的：

```python
"""在 Map 的所有键中搜索 query 的最长前缀
   longest_prefix_of("themxyz") -> "them" """
def longest_prefix_of(self, query: str) -> str:
	p = self.root
	max_len = 0
	for i, c in enumerate(query):
		if p is None:
			break
		max_len += 1
		p = p.children[c]
	return query[:max_len]
```




接下来我们只要对`TrieMap`做简单的封装，即可实现`TrieSet`：

```java
class TrieSet {
    // 底层用一个 TrieMap，键就是 TrieSet，值仅仅起到占位的作用
    // 值的类型可以随便设置，我参考 Java 标准库设置成 Object
    private final TrieMap<Object> map = new TrieMap<>();

    /***** 增 *****/

    // 在集合中添加元素 key
    public void add(String key) {
        map.put(key, new Object());
    }

    /***** 删 *****/

    // 从集合中删除元素 key
    public void remove(String key) {
        map.remove(key);
    }

    /***** 查 *****/

    // 判断元素 key 是否存在集合中
    public boolean contains(String key) {
        return map.containsKey(key);
    }

    // 在集合中寻找 query 的最短前缀
    public String shortestPrefixOf(String query) {
        return map.shortestPrefixOf(query);
    }

    // 在集合中寻找 query 的最长前缀
    public String longestPrefixOf(String query) {
        return map.longestPrefixOf(query);
    }

    // 在集合中搜索前缀为 prefix 的所有元素
    public List<String> keysWithPrefix(String prefix) {
        return map.keysWithPrefix(prefix);
    }

    // 判断集合中是否存在前缀为 prefix 的元素
    public boolean hasKeyWithPrefix(String prefix) {
        return map.hasKeyWithPrefix(prefix);
    }

    // 通配符 . 匹配任意字符，返回集合中匹配 pattern 的所有元素
    public List<String> keysWithPattern(String pattern) {
        return map.keysWithPattern(pattern);
    }

    // 通配符 . 匹配任意字符，判断集合中是否存在匹配 pattern 的元素
    public boolean hasKeyWithPattern(String pattern) {
        return map.hasKeyWithPattern(pattern);
    }

    // 返回集合中元素的个数
    public int size() {
        return map.size();
    }
}
```

**有了`TrieMap`和`TrieSet`，力扣上所有前缀树相关的题目都可以直接套用了**.