---
title: 拓扑排序 - Topological Sort - 模版
date: 2022-07-27 09:57:26
permalink: /pages/f665f9/
categories:
  - Google
  - 基本模版
tags:
  - 
---
## DFS Topological Sort
- 适合大部分情况
- 典型题：
	- [topological sort - course schedule 题](https://emmableu.github.io/blog/pages/e4e0f5)
	- [course schedule ii (print result)](https://emmableu.github.io/blog/pages/16db16/#description)
	- [Alien Dictionary](https://emmableu.github.io/blog/pages/543ced/)


## BFS Topological Sort
- 这里有 bfs 的算法： [course schedule ii (print result)](https://emmableu.github.io/blog/pages/16db16/#description)
- [2115 - Find All Possible Recipes from Given Supplies - Medium](https://emmableu.github.io/blog/pages/c7fa6e/) 这个题必须用bfs

## Solution 2 - BFS
### 解题思路：
本题可约化为： 课程安排图是否是 有向无环图(DAG)。即课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。

思路是通过拓扑排序判断此课程安排图是否是有向无环图(DAG)。 

拓扑排序原理： 对 DAG 的顶点进行排序，使得对每一条有向边 (u, v)，均有 u（在排序记录中）比 v 先出现。亦可理解为对某点 v 而言，只有当 v 的所有源点均出现了，v 才能出现。

通过课程前置条件列表 prerequisites 可以得到课程安排图的 邻接表 graph.

### 算法流程：
1. 生成入度表 `indegrees`  和 `graph`。
	1. 注意：判断谁做root方向：到时候谁要先出来， 谁就做root或者parent。这里，前置课程要先出来，所以前置课程就做root/parent
2. 借助一个**双向队列** `queue = deque()`，将所有入度为 0 的节点入队。
3. 当 `queue` 非空时，依次将队首节点出队，在课程安排图中删除此节点 `course`：
	- 并不是真正从邻接表中删除此节点 `course`，而是将此节点对应所有邻接节点 `child` 的入度 −1，即 `indegrees[child] -= 1`。
	- 当入度 −1 后邻接节点 `child` 的入度为 0，说明 `child` 所有的前驱节点已经被 “删除”，此时将 `child` 入队。	
4. 在每次 `course` 出队时，把 `course` 加到 `res` 里，这样可以得到一个正确的顺序。
	- 这里如果把图反过来建的话，res就不需要反过来，比如如果`[0，1]`得到`0`依赖于`1`，那么按照 `{1: [0]}` 建图，那么后面就不用反过来。
	- 若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 `0`。
	- 因此，拓扑排序出队次数等于课程个数，返回` len(res) = numCourses`, 则说明课程可以成功安排 判断课程是否可以成功安排。
	
复杂度分析：
- 时间复杂度 O(N+M)： 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量；
- 空间复杂度 O(N+M)： 为建立邻接表所需额外空间，adjacency 长度为 N ，并存储 M 条临边的数据。


