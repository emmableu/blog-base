---
title: 973 - K Closest Points to Origin
date: 2021-08-29 22:46:00
permalink: /pages/leetcode973
categories:
  - 
  - p5
tags:
  - heap
  - quickselect
  - 近期面经
---
## Description:
Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).

The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).

You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).


## Examples
```
example 1:
Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].


Example 2:
Input: points = [[3,3],[5,-1],[-2,4]], k = 2
Output: [[3,3],[-2,4]]
Explanation: The answer [[-2,4],[3,3]] would also be accepted.
```
## Constraints:

## solution 1: quick select (preferred)
- 先把points e.g. [[1,2], ...] 转化成 [[5, [1,2]], ...] 对这个做quick select
- 每次 返回 marker的index，marker的左边都小于marker。如果 小于k个，那就把l放在marker+1，如果大于k个，就把r放在marker-1, 如果等于k个，就返回。

partition 的过程：
1. set pivot point to the end. 
2. at every iteration, 比pivot小的放左边，比pivot大的放右边
    - swap小的元素到前面， 使用marker记录前面swap过的东西的下一个的position，固定大的元素。
3. 看最后pivot的index，如果比k小，再往pivot后面做partition，如果比k大，往pivot前面做partition

### code
```python
class Solution:
    def kClosest(self, points, k):
        
        def partition(l, r):
            pivot = dist[r]
            marker = l
            while l < r:
                if dist[l] < pivot:
                    dist[l], dist[marker] = dist[marker], dist[l]
                    marker += 1
                l += 1
            dist[r], dist[marker] = dist[marker], dist[r]
            return marker
        
        dist = [(x*x + y*y, x, y) for x, y in points]
        l, r = 0, len(dist)-1
        while True:
            marker = partition(l, r)
            if marker == k - 1:
                return [[x, y] for _, x, y in  dist[:marker+1]]
            if marker < k - 1:
                l = marker + 1
            elif marker > k - 1:
                r = marker - 1
```

### 时间复杂度分析

- time complexity: 
    - avg time complexity: O(n)
    - worst case time complexity: O(n^2) 
#### 为什么不是 n log n 
([来自stackoverflow](https://stackoverflow.com/questions/56940793/quickselect-time-complexity-explained))  
n log(n) implies that the algorithm looks at all N items log(n) times. But that's not what's happening with Quickselect.

Let's say you're using Quickselect to pick the top 8 items in a list of 128. And by some miracle of random selection, the pivots you pick are always at the halfway point.

On the first iteration, the algorithm looks at all 128 items and partitions into two groups of 64 items each. The next iteration splits into two groups of 32 items each. Then 16, and then 8. The number of items examined is:

`N + N/2 + N/4 + N/8 + N/16`  
The sum of that series will never reach 2*N.

The worst case is that partitioning always results in very skewed partition sizes. Consider what would happen if the first partitioning only removed one item. And the second only removed one, etc. The result would be:

`N + (N-1) + (N-2) ...`  
Which is (n^2 + n)/2), or `O(n^2)`.




## solution 2: max-heap
保持一个size 为 k 的maxheap，当有新的point进去的时候， 如果size >k, pop its top element. 最后当所有point都iterate一遍以后, 直接 return 这个size为k的maxheap (O(n lg k + k)) (the last return statement costs k time complexity)
```python
import heapq
class Solution:
    def kClosest(self, points, k):
        h = []
        for p in points:
            sqdist = - (p[0]*p[0] + p[1]*p[1])
            #sqdist need to use negative. since in python heaps are minheap by default
            heapq.heappush(h, (sqdist, p)) 
            #keep in mind that the first argument for heappush is the heap itself
            if len(h) == k+1:
                heapq.heappop(h)
                # keep in mind that heappop should be called by heapq (not h)
        return [ele[1] for ele in h]    
```