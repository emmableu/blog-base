---
title: Huffman Encoding And Decoding
date: 2021-12-10 14:12:15
permalink: /pages/9a7cdd/
categories:
  - 标准差
  - 题库
tags:
  - 
---
[online explanation](https://www.techiedelight.com/huffman-coding/)

## Method
### Heuristics
1. reduce the amount of space required to store a character   
所以用variable-length encoding.
2. decode things uniquely (avoid ambiguity):   
所以要满足prefix rule：no code is prefix to another code.   
如何满足这个条件：
    - 建一颗树，所有字符的encoding都是这棵树从root到对应叶子节点(leaf node) 的path
    - path 用左边0， 右边1表示
3. 为节省空间越常见的字符，应该让它对应的huffman字符数量越少  
如何满足这个条件：  
    - 建立一个尽量左矮右高的树，越常见的字符，就越往左边放。
    - 因为要用到频率，所以用priority queue
    

### Huffman encoding 算法：
注意，在priority queue中，因为是把低频字符先拿出来，所以越低频priority越高
1. Create a leaf node for each character and add them to the priority queue
2. While there's more than one node in the queue:
    - Remove the two nodes of the highest priority (the lowest frequency) from the queue
    - Create a new internal node with these two nodes as children, and a frequency equal to the sum of both nodes' frequencies.
    - Add the new node to the priority queue
3. The remaining node is the root node.

![](https://raw.githubusercontent.com/emmableu/image/master/huffman-encoding-0.png)
![](https://raw.githubusercontent.com/emmableu/image/master/huffman-encoding-1.png)


## Solution
```python
import heapq
from collections import Counter
from heapq import heappop, heappush
from typing import List, Dict


class Node:
    def __init__(self, ch, freq, left=None, right=None):
        self.ch = ch
        self.freq = freq
        self.left = left
        self.right = right

    def __lt__(self, other):
        return self.freq < other.freq


def is_leaf(root) -> bool:
    return root.left is None and root.right is None


def build_tree(original_text: str) -> Node:
    if len(original_text) == 0:
        return Node(None, 0)
    freq = Counter(original_text)

    pq = [Node(k, v) for k, v in freq.items()]

    heapq.heapify(pq)

    while len(pq) != 1:
        left = heappop(pq)
        right = heappop(pq)
        total = left.freq + right.freq
        heappush(pq, Node(None, total, left, right))

    return pq[0]


def get_huffman_code(root: Node) -> Dict:
    huffman_code = {}
    encode_helper(root, '', huffman_code)
    return huffman_code


def encode_helper(root: Node, s: str, huffman_code: Dict) -> None:
    if root is None:
        return
    if is_leaf(root):
        huffman_code[root.ch] = s if len(s) > 0 else '1'
    encode_helper(root.left, s + '0', huffman_code)
    encode_helper(root.right, s + '1', huffman_code)


def encode(root: Node, original_text: str) -> str:
    huffman_code = get_huffman_code(root)
    output = ''
    for c in original_text:
        output += huffman_code.get(c)
    return output


def decode_helper(root: Node, index: int, s: str, output: List) -> int:
    if root is None:
        return index
    if is_leaf(root):
        output.append(root.ch)
        return index
    root = root.left if s[index] == '0' else root.right
    return decode_helper(root, index + 1, s, output)


def decode(root: Node, encoded_text: str) -> str:
    output = []
    if is_leaf(root):
        while root.freq > 0:
            output.append(root.ch)
            root.freq -= 1
    else:
        index = 0
        while index < len(encoded_text):
            index = decode_helper(root, index, encoded_text, output)
    return ''.join(output)


if __name__ == '__main__':
    # text = 'Huffman coding is a data compression algorithm.'
    text = 'My name is Huffman'
    tree_root = build_tree(text)
    print('Original Text: ' + text)
    encoded = encode(tree_root, text)
    print('Encoded Text: ' + encoded)
    decoded = decode(tree_root, encoded)
    print('Decoded Text: ' + decoded)
```
